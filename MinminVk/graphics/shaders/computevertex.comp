#version 450

// https://github.com/godotengine/godot/blob/master/servers/rendering/renderer_rd/shaders/skeleton.glsl 

// skinning 
// inputs: 
// initial vertex buffer (position, normal, tangent)
// joint transforms
// outputs:
// new vertex position
// new normals
// new tangents

// morphing
// inputs:
// morph targets (position, normal, uv) 
// weights 
//outputs:
// new vertex buffer

layout(set = 0, binding = 1, std430) buffer DstVertexData {
	uint data[];
}
dst_vertices;

layout(set = 0, binding = 2, std430) readonly buffer  BlendShapeWeights {
	float data[];
}
blend_shape_weights;

layout(set = 1, binding = 0, std430) readonly buffer SrcVertexData {
	uint data[];
}
src_vertices;

layout(set = 1, binding = 1, std430) readonly buffer BoneWeightData {
	uint data[];
}
src_bone_weights;

layout(set = 1, binding = 2, std430) readonly buffer  BlendShapeData {
	uint data[];
}
src_blend_shapes;

layout(set = 2, binding = 0, std430) readonly buffer SkeletonData {
	vec4 data[];
}
bone_transforms;

layout(push_constant) uniform Params {
	bool has_normal;
	bool has_tangent;
	bool has_skeleton;
	bool has_blend_shape;

	uint vertex_count;
	uint vertex_stride;
	uint skin_stride;
	uint skin_weight_offset;

	uint blend_shape_count;
	bool normalized_blend_shapes;
	uint normal_tangent_stride;
	uint pad1;

//	vec2 skeleton_transform_x;
//	vec2 skeleton_transform_y;

//	vec2 skeleton_transform_offset;
//	vec2 inverse_transform_x;

//	vec2 inverse_transform_y;
//	vec2 inverse_transform_offset;
}
params;

vec2 uint_to_vec2(uint base) {
	uvec2 decode = (uvec2(base) >> uvec2(0, 16)) & uvec2(0xFFFF, 0xFFFF);
	return vec2(decode) / vec2(65535.0, 65535.0) * 2.0 - 1.0;
}

vec3 oct_to_vec3(vec2 oct) {
	vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));
	float t = max(-v.z, 0.0);
	v.xy += t * -sign(v.xy);
	return normalize(v);
}

vec3 decode_uint_oct_to_norm(uint base) {
	return oct_to_vec3(uint_to_vec2(base));
}

vec4 decode_uint_oct_to_tang(uint base) {
	vec2 oct_sign_encoded = uint_to_vec2(base);
	// Binormal sign encoded in y component
	vec2 oct = vec2(oct_sign_encoded.x, abs(oct_sign_encoded.y) * 2.0 - 1.0);
	return vec4(oct_to_vec3(oct), sign(oct_sign_encoded.y));
}

vec2 signNotZero(vec2 v) {
	return mix(vec2(-1.0), vec2(1.0), greaterThanEqual(v.xy, vec2(0.0)));
}

uint vec2_to_uint(vec2 base) {
	uvec2 enc = uvec2(clamp(ivec2(base * vec2(65535, 65535)), ivec2(0), ivec2(0xFFFF, 0xFFFF))) << uvec2(0, 16);
	return enc.x | enc.y;
}

vec2 vec3_to_oct(vec3 e) {
	e /= abs(e.x) + abs(e.y) + abs(e.z);
	vec2 oct = e.z >= 0.0f ? e.xy : (vec2(1.0f) - abs(e.yx)) * signNotZero(e.xy);
	return oct * 0.5f + 0.5f;
}

uint encode_norm_to_uint_oct(vec3 base) {
	return vec2_to_uint(vec3_to_oct(base));
}

uint encode_tang_to_uint_oct(vec4 base) {
	vec2 oct = vec3_to_oct(base.xyz);
	// Encode binormal sign in y component
	oct.y = oct.y * 0.5f + 0.5f;
	oct.y = base.w >= 0.0f ? oct.y : 1 - oct.y;
	return vec2_to_uint(oct);
}

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main() 
{
// vertex data 
// vec3 pos;
// vec3 color = vec3(1);
// vec2 texCoord;
// vec3 normal = vec3(0,0,1);
// vec4 tangent = vec4(0);

	uint index = gl_GlobalInvocationID.x;
	if (index >= params.vertex_count) {
		return;
	}

	uint src_offset = index * params.vertex_stride;

	vec3 vertex;
	vec3 normal;
	vec4 tangent;

	vertex = uintBitsToFloat(uvec3(src_vertices.data[src_offset + 0], src_vertices.data[src_offset + 1], src_vertices.data[src_offset + 2]));
	normal = uintBitsToFloat(uvec3(src_vertices.data[src_offset + 8], src_vertices.data[src_offset + 9], src_vertices.data[src_offset + 10]));
	tangent = uintBitsToFloat(uvec4(src_vertices.data[src_offset + 11], src_vertices.data[src_offset + 12], src_vertices.data[src_offset + 13], src_vertices.data[src_offset + 14]));
	

	if (params.has_blend_shape)
	{
		// TODO 
	}

	if (params.has_skeleton)
	{
		uint skin_offset = params.skin_stride * index;
		uvec4 bones = uvec4(src_bone_weights.data[skin_offset + 0], src_bone_weights.data[skin_offset + 1], src_bone_weights.data[skin_offset + 2], src_bone_weights.data[skin_offset + 3]);
		skin_offset += params.skin_weight_offset;
		uvec4 weights = uvec4(src_bone_weights.data[skin_offset + 0], src_bone_weights.data[skin_offset + 1], src_bone_weights.data[skin_offset + 2], src_bone_weights.data[skin_offset + 3]);

		mat4 skinMatrix = 
			weights.x * mat4(bone_transforms.data[bones.x], bone_transforms.data[bones.x + 1], bone_transforms.data[bones.x + 2], vec4(0.0, 0.0, 0.0, 1.0))  +
			weights.y * mat4(bone_transforms.data[bones.y], bone_transforms.data[bones.y + 1], bone_transforms.data[bones.y + 2], vec4(0.0, 0.0, 0.0, 1.0)) +
			weights.z * mat4(bone_transforms.data[bones.z], bone_transforms.data[bones.z + 1], bone_transforms.data[bones.z + 2], vec4(0.0, 0.0, 0.0, 1.0)) +
			weights.w * mat4(bone_transforms.data[bones.w], bone_transforms.data[bones.w + 1], bone_transforms.data[bones.w + 2], vec4(0.0, 0.0, 0.0, 1.0));

		//reverse order because its transposed
		vertex = (vec4(vertex, 1.0) * skinMatrix).xyz;
		normal = normalize((vec4(normal, 0.0) * skinMatrix).xyz);
		tangent.xyz = normalize((vec4(tangent.xyz, 0.0) * skinMatrix).xyz);
	}

	uint dst_offset = index * params.vertex_stride;

	uvec3 uvertex = floatBitsToUint(vertex);
	dst_vertices.data[dst_offset + 0] = uvertex.x;
	dst_vertices.data[dst_offset + 1] = uvertex.y;
	dst_vertices.data[dst_offset + 2] = uvertex.z;

	uvec3 unormal = floatBitsToUint(normal);
	dst_vertices.data[dst_offset + 8] = unormal.x;
	dst_vertices.data[dst_offset + 9] = unormal.y;
	dst_vertices.data[dst_offset + 10] = unormal.z;
	
	uvec4 utangent = floatBitsToUint(tangent);
	dst_vertices.data[dst_offset + 11] = utangent.x;
	dst_vertices.data[dst_offset + 12] = utangent.y;
	dst_vertices.data[dst_offset + 13] = utangent.z;
	dst_vertices.data[dst_offset + 14] = utangent.z;

}