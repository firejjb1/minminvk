#version 450

struct Particle { 
	vec4 position;
    vec4 color;
};

layout (binding = 0) uniform ParameterUBO {
    float deltaTime;
    uint numVertexPerThread;
    uint frame;
} ubo;

// at beginning of frame: ParticlesIn holds current particle info, ParticlesOut holds previous particle info
// at end of frame: ParticlesIn holds same (becomes the previous info next frame), ParticlesOut holds new particle info
// each dispatch exchanges ParticlesIn and ParticlesOut

layout(std140, binding = 1) readonly buffer ParticleSSBOIn {
   Particle particlesIn[ ];
};

layout(std140, binding = 2) buffer ParticleSSBOOut {
   Particle particlesOut[ ];
};

layout(std140, binding = 3) readonly buffer ParticleSSBOInitial
{
    Particle particlesInitial[];
};

float gravityMag = 9.8f;

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
void main() 
{
    uint index = gl_GlobalInvocationID.x;  

    Particle particleIn = particlesIn[index];
    uint localVertexIndex = uint(particleIn.position.w);

    vec3 force = gravityMag * vec3(0.f, 1.f, 0.f);
    vec3 curPos = particleIn.position.xyz;
    bool isMovable = particleIn.position.w > 40;
    vec3 initialPos = particlesInitial[index].position.xyz;
    if (!isMovable)
    {
        particlesOut[index].position = vec4(initialPos, 1);
        return;
    }
    vec3 oldPos = particlesOut[index].position.xyz;
    float decay = exp(-1.f * ubo.deltaTime * 60.f);
    vec3 newPos = curPos + (curPos - oldPos) * decay + force * ubo.deltaTime * ubo.deltaTime;

    // Global Shape Constraints
    float stiffnessForGlobalShapeMatching =  0.1f;//GetGlobalStiffness(strandType);
    float globalShapeMatchingEffectiveRange = 1.0f;//GetGlobalRange(strandType);
    if ( stiffnessForGlobalShapeMatching > 0 && globalShapeMatchingEffectiveRange > 0 )
    {
        if ( float(localVertexIndex) < globalShapeMatchingEffectiveRange * float( ubo.numVertexPerThread) )
        {
            float factor = stiffnessForGlobalShapeMatching;
            vec3 del = factor * (initialPos - newPos).xyz;
            newPos += del;
        }
    }
    particlesOut[index].position = vec4(newPos, particleIn.position.w);

    groupMemoryBarrier();

    // local constraint tmp 
    // TODO Need to be strand level (sequential vertex order)
    /**
    float localConstraintFactor = 0.3f;
    vec3 D = initialPos - newPos;
    particlesOut[index-1].position -= vec4(localConstraintFactor * 0.5f * D, 0); 
    particlesOut[index].position += vec4(localConstraintFactor * 0.5f * D, 0); 
    */

    groupMemoryBarrier();

    // wind force tmp
    if (index % ubo.numVertexPerThread > 0)
    {
        float magnitudeWind = sin(sin(float(ubo.frame) * 0.05f)) + 0.5f;
        magnitudeWind *= (float(localVertexIndex) / float(ubo.numVertexPerThread) * 30.f);
        vec3 V = (particlesOut[index-1].position - particlesOut[index].position).xyz;
        vec3 W = magnitudeWind * vec3(-1.f, -0.f, 0.f);
        /**
        vec3 W1 = W;
        vec3 W2 = W;
        vec3 W3 = W;
        vec3 W4 = W;
        W1.x -= 0.1f;
        W2.x += -.1f;
        W3.y -= 0.1f;
        W4.y += 0.1f;
        */
        
        vec3 F = W; // W1 + W2 + W3 + W4; //-cross(cross(V, W), V);
        particlesOut[index].position += vec4(F * ubo.deltaTime * ubo.deltaTime, 0);
    }
    
}